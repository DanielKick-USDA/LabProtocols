{
  "hash": "7cd605a1bc3cf3713dce3a8363995b21",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Defining Training Sets with _Radically_ Unbalanced Data\"\nsubtitle: \"\"\nauthor: \"Daniel Kick\"\ndate: \"2024-10-07\"\nimage: \"\"\ncategories: \n  - simulation\n  - python\n  - beginner\nfreeze: true\n---\n\n::: {#9513322f .cell execution_count=1}\n``` {.python .cell-code}\n# lets do some hypothetical clustering\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nrng = np.random.default_rng(seed=42)\n\ncvf = 5\nk = 100\n\n\n# best case \n# cluster_count = rng.integers(10, 11, k)\n\ncluster_count = rng.integers(1, 100, k)\n\ncluster_count = np.ceil(rng.exponential(10, k)).astype(int)\n\n# # cluster_count = np.ceil(rng.pareto(10, k)*10.).astype(int) # less extreme pareto\n\n# cluster_count = np.ceil(rng.pareto(2, k)*10.).astype(int) # more extreme pareto\n\n\ncluster_ids   = np.linspace(0, (k-1), k).astype(int)\n# print(cluster_count)\n\n# noisily order with respect to size\ndef noisily_order(cct = cluster_count):\n    k = cct.shape[0]\n    cid = np.linspace(0, (k-1), k).astype(int)\n\n    out = np.zeros_like(cct)\n    for i in range(k):\n        # draw cluster proportionate to cluster size\n        # _ = rng.choice(cid, 1, p=cct/cct.sum())[0]\n\n        # Trying to decrease test set cluster iou with a normalization factor\n        probs = cct + cluster_count.mean()\n\n\n        _ = rng.choice(cid, 1, p=(probs)/probs.sum() )[0]\n        out[i] = _\n        cct = cct[cid != _]\n        cid = cid[cid != _]\n    return out\n\n_ = plt.hist(cluster_count)\n\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-2-output-1.png){width=566 height=411}\n:::\n:::\n\n\n::: {#741e0411 .cell execution_count=2}\n``` {.python .cell-code}\ncluster_count.mean()\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nnp.float64(10.21)\n```\n:::\n:::\n\n\n::: {#0c2712cc .cell execution_count=3}\n``` {.python .cell-code}\nreorder = [noisily_order(cct = cluster_count) for fold in range(cvf)]\n\n_ = np.concatenate([cluster_count[e][:, None] for e in reorder], axis = 1)\n\n# calculate cumulative percent of dataset\n_pr = (_/cluster_count.sum()).cumsum(axis=0)\n```\n:::\n\n\n::: {#70303670 .cell execution_count=4}\n``` {.python .cell-code}\nplt.imshow(_.T)\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-5-output-1.png){width=571 height=70}\n:::\n:::\n\n\n::: {#a8789cf5 .cell execution_count=5}\n``` {.python .cell-code}\nplt.plot(_pr)\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-6-output-1.png){width=571 height=411}\n:::\n:::\n\n\n::: {#b02bfc6e .cell execution_count=6}\n``` {.python .cell-code}\nplt.imshow(_pr.T)\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-7-output-1.png){width=571 height=70}\n:::\n:::\n\n\n::: {#a530e214 .cell execution_count=7}\n``` {.python .cell-code}\n# for fold in range(cvf)],\nfold = 0\n\n\n# cluster ints for the validation/test sets\nval = {fold: reorder[fold][(_pr[:, fold] > .80)] for fold in range(cvf)}\nval = {k: set(val[k]) for k in val}\n# _[(_pr[:, fold] > .80), fold]\n\n```\n:::\n\n\n::: {#a1d5c745 .cell execution_count=8}\n``` {.python .cell-code}\niou = np.zeros((cvf, cvf))\n\nfor i in val:\n    for j in val:\n        iou[i,j] = len(set.intersection(val[i], val[j]))/len(set.union(val[i], val[j]))\n\n\n# This is kinda fancy indexing to select the upper triangle without diagonal\nplt.hist( iou[np.tril(np.ones_like(iou)) == 0] )\n\nprint(iou)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1.         0.20408163 0.24489796 0.17241379 0.1372549 ]\n [0.20408163 1.         0.2173913  0.26       0.12765957]\n [0.24489796 0.2173913  1.         0.16071429 0.25      ]\n [0.17241379 0.26       0.16071429 1.         0.16981132]\n [0.1372549  0.12765957 0.25       0.16981132 1.        ]]\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-9-output-2.png){width=579 height=411}\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}