{
  "hash": "ea80d834ea016ff9a5869701419266ba",
  "result": {
    "markdown": "---\ntitle: \"QR Code Generation\"\nauthor: \"Daniel Kick\"\ndate: \"2/27/2024\"\ndate-modified: \"2/27/2024\"\nexecute:\n  freeze: true\n---\n\n\n# QR Codes for Easier Record Keeping\nFor certain tasks in the lab we use QR code to label plants, samples, or other materials. Generating these can take a bit of doing, so we have a few simple scripts to do this. Ideally, we want to make our labels both machine _and_ human readable so we will produce labels with text alongside the QR code. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readxl)\nlibrary(qrcode)\nlibrary(tidyverse)\n\nmk_qr_label <- function(\n    plot = 1,\n    field = 1,\n    pedigree = 'CM48',\n    max_len = 12,\n    output_dir = './output/'\n){\n  # clean inputs\n  plot     <- as.character(plot)\n  field    <- as.character(field)\n  pedigree <- as.character(pedigree)\n  \n  # info to be embedded\n  label <- paste(c(field, '_', pedigree), collapse='')\n  \n  # Set up save name\n  savename  <- paste(plot, field, stringr::str_replace_all(label,  '/', '\\\\'), \n                     sep = '_')\n  save_path <- paste(output_dir, savename, \".svg\", sep = '')\n  \n  # create qr code\n  code  <- qr_code(label)\n  \n  # reshape for ggplot\n  code_long <- pivot_longer(mutate(\n    X = seq(1, nrow(as.data.frame(code))),\n    as.data.frame(code)), \n    cols = starts_with('V')) %>% \n    mutate(Y = -1*as.numeric(str_remove(name, 'V')))\n  \n  # create text for ggplot\n  align_label <- paste(\n    c(plot, \n      paste0(rep(' ', max(c(0, (max_len - stringr::str_length(pedigree)))))),\n      field, \n      paste0(rep(' ', max(c(0, (max_len - stringr::str_length(field)))))),\n      pedigree), collapse = '')\n  \n  # make plot\n  plt <- ggplot(code_long)+\n    geom_tile(aes(X, Y, fill = value))+\n    annotate(geom = \"text\", \n             x = min(filter(code_long, value)$X), \n             y = -1, \n             label = align_label,\n             hjust = 0, \n             size = 11\n    )+\n    scale_fill_manual(values = c('white', 'black'))+\n    theme_void()+\n    theme(legend.position = '')+\n    coord_equal()\n  \n  return(list('qr'=plt, 'path'=save_path))  \n}\n```\n:::\n\n\nUse of this function is straight forward. It accepts numeric or text data for the plot, field, and pedigree of a plant. To ensure these attributes are positioned in a way that is easy to read, `max_len` adds spaces after each (up to the number specified). This results in text that is separated cleanly. The function returns a plot of the QR and the expected location for it to be saved. This will enable future extensions such as writing a batch of qr codes to a word document with `officer` for easy printing.\n\n::: {.cell}\n\n```{.r .cell-code}\noutput_list <- mk_qr_label(\n    plot       = 1,\n    field      = 1,\n    pedigree   = 'CM48',\n    max_len    = 12,\n    output_dir = './output/'\n)\n\nprint(output_list$path)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"./output/1_1_1_CM48.svg\"\n```\n:::\n\n```{.r .cell-code}\noutput_list$qr\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nUse for batch processing is simple. We need to read in a spreadsheet with the label information and ensure that there are no missing values.Then we can loop over the entries and pass the output of `mk_qr_label` into `ggsave` and it will save them to the output directory.\n\n::: {.cell}\n\n```{.r .cell-code}\nlabels <- read_excel('./Grain_Labels_Demo.xlsx')\n\n# overwrite key fields with character version and add in missing labels for NAs\nwalk(c(\"Plot\", \"Field\", \"Pedigree\"), function(e){\n  labels[[e]] <<- as.character(labels[[e]])\n  labels[is.na(labels[[e]]), e] <<- 'MISSING'\n})\n\nfor(i in seq(1, nrow(labels))){\n  output_list <- mk_qr_label(\n    plot       = labels[i, 'Plot'],\n    field      = labels[i, 'Field'],\n    pedigree   = labels[i, 'Pedigree'],\n    max_len    = 12,\n    output_dir = './output/'\n  )\n  ggsave(filename = output_list$path,\n         plot     = output_list$qr\n  )\n}\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}